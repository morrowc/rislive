
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">./rislive.go (28.2%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package rislive implements a service to listen to the RIPE RIS Live service,
// Messages from RIS Live are parsed and sent to a channel for use be clients.
// There are filter capabilities for clients:
//  ASPaths - monitor for prefixes matching an as-path fragment (slice)
//  InvalidTransitAS - monitor for prefixes transiting an AS that shouldn't transit that AS. (map)
//  Origins - monitor for prefixes with designated origins (slice)
//  Prefix - monitor for a designated set of prefixes (slice)
//
package rislive

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "reflect"
)

// RisLive is a struct to hold basic data used in connecting to the RIS Live service
// and managing data output/collection for the calling client.
type RisLive struct {
        Url     *string
        File    *string
        UA      *string
        Filter  *RisFilter
        Records int64
        Chan    chan RisMessage
}

// RisFilter is an object to hold content used to filter the collected BGP
// routes before display to the caller.
type RisFilter struct {
        ASPath           []int32        // Asath: [701, 7018, 3356] a fragment of the aspath seen.
        InvalidTransitAS map[int32]bool // {"701":true, "3356":true}.
        Origins          []string       // A list of interesting origin ASH.
        Prefix           []string       // Prefix: ["1.2.3.0/24", "2001:db8::/32"] a list of prefixes.
}

// RisMessage is a single ris_message json message from the ris firehose.
type RisMessage struct {
        Type string          `json:"type"`
        Data *RisMessageData `json:"data"`
}

// RisMessageData is the BGP oriented content of the single RisMessage message type.
type RisMessageData struct {
        Timestamp     float64            `json:"timestamp"`
        Peer          string             `json:"peer"`
        PeerASN       string             `json:"peer_asn,omitempty"`
        Id            string             `json:"id"`
        Host          string             `json:"host"`
        Type          string             `json:"type"`
        Path          []int32            `json:"path"`
        Community     [][]int32          `json:"community"`
        Origin        string             `json:"origin"`
        Announcements []*RisAnnouncement `json:"announcements"`
        Raw           string             `json:"raw"`
}

// MatchASPath matches a fragment of an aspath with a<span class="cov8" title="1">n as-path in an announcement.
func (r *RisMessageData) MatchASPath(c []int32) bool {
        cLen := len(c)
        // If the announcement</span><span class="cov8" title="1">'s aspath is shorter than the candidate, no match is possible.
        if len(r.Path) &lt; cLen {
                </span>return false
        }
        <span class="cov8" title="1">// Slide the candidate along the annou</span><span class="cov8" title="1">ncement path checking for a match.
        for i := 0; i+cLen &lt; len(r.Path); i++ {
                frag := r.Path[i:(i + cLen)]
</span>                if reflect.DeepEqual(frag, c) {
                        </span>return true
                }
        <span class="cov8" title="1">}
</span>        return false
}

// InvalidTransitAS matches a set of ASN in the RisMessageData.Path, returning true if
// there is a match in the Path. This should be used to alert on invalid paths seen, paths
// which do not match intent/expectations of the announcing ASN.
func (r *RisMessageData) I</span><span class="cov8" title="1">nvalidTransitAS(c map[int32]bool) bool {
        for _, p </span><span class="cov8" title="1">:= range r.Path {
                if c[p] {
                        </span>return true
                }
        <span class="cov8" title="1">}
</span>        return false
}

func (r *RisMessageData) CheckOr</span><span class="cov0" title="0">igins(origins []string) bool {
        for _, origin := range </span><span class="cov0" title="0">origins {
                if r.Origin == origin {
                        </span>return true
                }
        <span class="cov0" title="0">}
</span>        return false
}

// RisAnnouncement is a struct which holds the prefixes contained in the single Bgp Message.
type RisAnnouncement struct {
        NextHop  string   `json:"next_hop"`
        Prefixes []string `json:"prefixes"`
}

// MatchPrefix matches a list of prefixes against an announcement's included prefixes.
// Is an exact match, does not implement any super/subne<span class="cov8" title="1">t matching conditions.
func (r *RisAnnounceme</span><span class="cov8" title="1">nt) MatchPrefix(cs []string) bool {
        for _, c := range cs {
</span>                for _, p :=</span><span class="cov8" title="1"> range r.Prefixes {
                        if c == p {
                                </span>return true
                        }
                }
        <span class="cov8" title="1">}
</span>        return false
}

// NewRisFilter creates a new RisFilter struct.
func NewRisFilter(aspath []int32, transits map[int32]bool, origins, prefix []string) *RisFilter {
        return &amp;RisFilter{
                ASPath:           aspath,
                InvalidTransitAS: transits,
                Origins:          origins,
                Prefix:           prefix,
        </span>}
}

// NewRisLive creates a new RisLive struct.
func NewRisLive(url, file, ua *string, rf *RisFilter, buffer *int) *RisLive {
        return &amp;RisLive{
                Url:     url,
                File:    file,
                UA:      ua,
                Filter:  rf,
                Records: 0,
                Chan:    make(chan (RisMessage), buffer),
        </span>}
}

// Listen connects to the RisLive service, parses the stream into structs
// and makes the data strea<span class="cov0" title="0">m available for analysis through the RisLive.Chan channel.
func (r *RisLive) Listen() {
        var body io.ReadCloser
</span>        switch len<span class="cov0" title="0">(*r.File) == 0 {
        case true:
                client := &amp;http.Client{}
                req, err := ht</span><span class="cov0" title="0">tp.NewRequest("GET", *r.Url, nil)
                if err != nil {
                        </span>fmt.Printf("failed to create new request to ris-live: %v\n", err)
                <span class="cov0" title="0">}
                req.Header.Set("User-Agent", *r.UA)
                resp, err := client.Do(req)
                defer resp.Body.</span>Close()
                body = <span class="cov0" title="0">resp.Body
        default:
                fd, err := iou</span><span class="cov0" title="0">til.ReadFile(*r.File)
                if err != nil {
                        </span>fmt.Printf("failed to read risFile(%v): %v\n", *r.File, err)
                <span class="cov0" title="0">}
</span>                body = ioutil.NopCloser(bytes.NewReader(fd))
        }

        dec := json.NewDecoder(body)

        var rm RisMessa</span><span class="cov0" title="0">ge
        for dec.More() {
                err := dec.Dec</span><span class="cov0" title="0">ode(&amp;rm)
                if err != nil {
                        fmt.Printf("failed to decode json: %v\n", err)
                        fmt.Printf("bad json content: %v\n", rm)
                        </span>return
                <span class="cov0" title="0">}
                r.Records++
</span>                r.Chan &lt;- rm
        }
}

// Get collects messages from the RisLive.Chan chann<span class="cov0" title="0">el and filters results prior
// to</span><span class="cov0" title="0"> display or handling downstream.
func (r *RisLive) Get(f *RisFilter) chan RisMessage {
        for {
                rm := &lt;-r.Chan
                rmd := rm.Data
</span>                prefix := ""
</span>                if len(rmd.Announcements) &gt; 0 {
                        i</span>f len(rmd.Announcements[0].Prefixes) &gt; 0 {
                                prefix = rmd.Announcements[0].Prefixes[0]
                <span class="cov0" title="0">        }
</span>                }
                fmt.Printf("Message(%d): Peer/ASN -&gt; %v/%v Prefix1: %v\n", r.Records, rmd.Peer, rmd.PeerASN, prefix)
        }
}

// CheckASPath checks the filterable ASPath, if it's se<span class="cov8" title="1">t.
// If not set, always return </span><span class="cov8" title="1">true.
func (r *RisLive) CheckASPath(rm *RisMessageData) bool {
        i</span>f len(r.Filter.ASPath) &gt; 0 {
        <span class="cov8" title="1">        return rm.</span>MatchASPath(r.Filter.ASPath)
        }
        return true
}

// CheckInvalidTransitAS checks to see if there is a marked inval<span class="cov0" title="0">id ASN in the as-path.
// If there is no map, this check retur</span><span class="cov0" title="0">ns false: there is nothing to match, so no match.
func (r *RisLive) CheckInvalidTransitAS(rm *RisMessageData) bool {
        i</span>f len(r.Filter.InvalidTransitAS) &gt; 0 {
        <span class="cov0" title="0">        return rm.I</span>nvalidTransitAS(r.Filter.InvalidTransitAS)
        }
        return false
}

// CheckOrigins checks the inbound message origin agains<span class="cov0" title="0">t a list of possible origins.
// If there is no list of orig</span><span class="cov0" title="0">ins, return true: no match means show all origins.
func (r *RisLive) CheckOrigins(rm *RisMessageData) bool {
        i</span>f len(r.Filter.Origins) &gt; 0 {
        <span class="cov0" title="0">        return rm.</span>CheckOrigins(r.Filter.Origins)
        }
        return true
}

// CheckPrefix will check each announcement in a message, and return true
// if there is a prefix in the message that matches the watched prefixes.
// These are exact matches of strings, there is no super/subnet/covering route
// check being performed, ie:
//   192.168.0.0/16 vs 192.168.0.0/16 - match
//   192.168.0.0/16 vs 192.168.0.0/24 - no match
// TODO(morrowc): Provide super/subnet verification of <span class="cov0" title="0">each announced prefix
// to the requestors list of </span><span class="cov0" title="0">supernets.
func (r *RisLive) CheckPrefix(rm *RisMes</span><span class="cov0" title="0">sageData) bool {
        if len(r.Filter.Prefix) &gt; 0 {
</span>                for _, anns := range rm.Announcements {
</span>                        for _, prefix := rang</span><span class="cov0" title="0">e anns.Prefixes {
                                for _, check := range r.Filter.Prefix {
                                        i</span>f prefix == check {
                                                return true
                                        }
                                }
                        }
        <span class="cov0" title="0">        }
</span>        }
        return true
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
