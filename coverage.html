
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">/home/morrowc/scripts/git/rislive/rislive.go (76.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package rislive implements a service to listen to the RIPE RIS Live service,
// Messages from RIS Live are parsed and sent to a channel for use be clients.
// There are filter capabilities for clients:
//  ASPaths - monitor for prefixes matching an as-path fragment (slice)
//  InvalidTransitAS - monitor for prefixes transiting an AS that shouldn't transit that AS. (map)
//  Origins - monitor for prefixes with designated origins (slice)
//  Prefix - monitor for a designated set of prefixes (slice)
//
package main

import (
        "bytes"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "reflect"

        log "github.com/golang/glog"
)

var (
        risFile   = flag.String("risFile", "", "A file of json content, to help in testing.")
        risLive   = flag.String("rislive", "https://ris-live.ripe.net/v1/stream/?format=json", "RIS Live firehose url")
        risClient = flag.String("risclient", "golang-rislive-morrowc", "Clientname to send to rislive")
        buffer    = flag.Int("buffer", 1000, "Max depth of Ris messages to queue.")
)

// RisLive is a struct to hold basic data used in connecting to the RIS Live service
// and managing data output/collection for the calling client.
type RisLive struct {
        URL     *string
        File    *string
        UA      *string
        Filter  *RisFilter
        Records int64
        Chan    chan RisMessage
}

// RisFilter is an object to hold content used to filter the collected BGP
// routes before display to the caller.
type RisFilter struct {
        ASPath           []int32        // Asath: [701, 7018, 3356] a fragment of the aspath seen.
        InvalidTransitAS map[int32]bool // {"701":true, "3356":true}.
        Origins          []string       // A list of interesting origin ASH.
        Prefix           []string       // Prefix: ["1.2.3.0/24", "2001:db8::/32"] a list of prefixes.
}

// RisMessage is a single ris_message json message from the ris firehose.
type RisMessage struct {
        Type string          `json:"type"`
        Data *RisMessageData `json:"data"`
}

// RisMessageData is the BGP oriented content of the single RisMessage message type.
type RisMessageData struct {
        Timestamp     float64       `json:"timestamp"`
        Peer          string        `json:"peer"`
        PeerASN       string        `json:"peer_asn,omitempty"`
        ID            string        `json:"id"`
        Host          string        `json:"host"`
        Type          string        `json:"type"`
        Path          []interface{} `json:"path"`
        DigestedPath  []int32
        Community     [][]int32          `json:"community"`
        Origin        string             `json:"origin"`
        Announcements []*RisAnnouncement `json:"announcements"`
        Raw           string             `json:"raw"`
}

// MatchASPath matches a fragment of an aspath with an as-path in an announcement.
func (r *RisMessageData) MatchASPath(c []int32) bool <span class="cov8" title="1">{
        cLen := len(c)
        // If the announcement's aspath is shorter than the candidate, no match is possible.
        if len(r.DigestedPath) &lt; cLen </span><span class="cov8" title="1">{
                return false
        }</span>
        // Slide the candidate along the announcement path checking for a match.
        <span class="cov8" title="1">for i := 0; i+cLen &lt; len(r.DigestedPath); i++ </span><span class="cov8" title="1">{
                frag := r.DigestedPath[i:(i + cLen)]
                if reflect.DeepEqual(frag, c) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// InvalidTransitAS matches a set of ASN in the RisMessageData.Path, returning true if
// there is a match in the Path. This should be used to alert on invalid paths seen, paths
// which do not match intent/expectations of the announcing ASN.
func (r *RisMessageData) InvalidTransitAS(c map[int32]bool) bool <span class="cov8" title="1">{
        for _, p := range r.DigestedPath </span><span class="cov8" title="1">{
                if c[p] </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// CheckOrigins checks the message's bgp Origin Attribute matches a list of possible origins.
func (r *RisMessageData) CheckOrigins(origins []string) bool <span class="cov8" title="1">{
        for _, origin := range origins </span><span class="cov8" title="1">{
                if r.Origin == origin </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// RisAnnouncement is a struct which holds the prefixes contained in the single Bgp Message.
type RisAnnouncement struct {
        NextHop  string   `json:"next_hop"`
        Prefixes []string `json:"prefixes"`
}

// MatchPrefix matches a list of prefixes against an announcement's included prefixes.
// Is an exact match, does not implement any super/subnet matching conditions.
func (r *RisAnnouncement) MatchPrefix(cs []string) bool <span class="cov8" title="1">{
        for _, c := range cs </span><span class="cov8" title="1">{
                for _, p := range r.Prefixes </span><span class="cov8" title="1">{
                        if c == p </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// NewRisFilter creates a new RisFilter struct.
func NewRisFilter(aspath []int32, transits map[int32]bool, origins, prefix []string) *RisFilter <span class="cov8" title="1">{
        return &amp;RisFilter{
                ASPath:           aspath,
                InvalidTransitAS: transits,
                Origins:          origins,
                Prefix:           prefix,
        }
}</span>

// NewRisLive creates a new RisLive struct.
func NewRisLive(url, file, ua *string, rf *RisFilter, buffer *int) *RisLive <span class="cov8" title="1">{
        return &amp;RisLive{
                URL:     url,
                File:    file,
                UA:      ua,
                Filter:  rf,
                Records: 0,
                Chan:    make(chan (RisMessage), *buffer),
        }
}</span>

func digestPath(m *RisMessageData) error <span class="cov8" title="1">{
        m.DigestedPath = []int32{}
        for _, p := range m.Path </span><span class="cov8" title="1">{
                switch v := p.(type) </span>{
                case int:<span class="cov8" title="1">
                        m.DigestedPath = append(m.DigestedPath, int32(v))</span>
                case float64:<span class="cov8" title="1">
                        m.DigestedPath = append(m.DigestedPath, int32(v))</span>
                case []interface{}:<span class="cov8" title="1">
                        // Convert p to a slice of interface.
                        listSlice, ok := p.([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New(fmt.Sprintf("failed to cast path element: %v as %v", p, reflect.TypeOf(p)))
                        }</span>
                        <span class="cov8" title="1">for _, e := range listSlice </span><span class="cov8" title="1">{
                                m.DigestedPath = append(m.DigestedPath, int32(e.(float64)))
                        }</span>
                default:<span class="cov8" title="1">
                        return errors.New(fmt.Sprintf("failed to decode path element: %v as %v", p, reflect.TypeOf(p)))</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Listen connects to the RisLive service, parses the stream into structs
// and makes the data stream available for analysis through the RisLive.Chan channel.
func (r *RisLive) Listen() <span class="cov8" title="1">{
        var body io.ReadCloser
        // If there's a file provided read/use that, else open the remote
        // socket and consume the firehose.
        switch len(*r.File) == 0 </span>{
        case true:<span class="cov8" title="1">
                log.Infof("Reading from the firehose...")
                client := &amp;http.Client{}
                req, err := http.NewRequest("GET", *r.URL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to create new request to ris-live: %v\n", err)
                }</span>
                <span class="cov8" title="1">req.Header.Set("User-Agent", *r.UA)
                resp, err := client.Do(req)
                defer resp.Body.Close()
                body = resp.Body</span>
        default:<span class="cov8" title="1">
                log.Infof("Heres a file read")
                fd, err := ioutil.ReadFile(*r.File)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to read risFile(%v): %v\n", *r.File, err)
                }</span>
                <span class="cov8" title="1">body = ioutil.NopCloser(bytes.NewReader(fd))
                log.Infof("Finished Reading File")</span>
        }

        <span class="cov8" title="1">dec := json.NewDecoder(body)

        // Remove log file once done.
        f, err := os.Create("/tmp/log")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to open log file: %v", err)
        }</span>
        <span class="cov8" title="1">defer f.Close()
        for </span><span class="cov8" title="1">{
                var rm RisMessage
                err := dec.Decode(&amp;rm)
                switch </span>{
                case err != nil &amp;&amp; err != io.EOF:<span class="cov0" title="0">
                        _, err := f.WriteString(fmt.Sprintf("bad json content: %+v\n", rm.Data))
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("failed to write to log: %v", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                case err == io.EOF:<span class="cov8" title="1">
                        close(r.Chan)
                        return</span>
                }
                <span class="cov8" title="1">err = digestPath(rm.Data)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("decoding the message data path(%v) failed: %v\n", rm.Data.Path, err)
                        log.Infof("decoding the message data path(%v) failed: %v", rm.Data.Path, err)
                }</span>
                <span class="cov8" title="1">r.Records++
                r.Chan &lt;- rm</span>
        }
}

// Get collects messages from the RisLive.Chan channel and filters results prior
// to display or handling downstream.
func (r *RisLive) Get(f *RisFilter) string <span class="cov0" title="0">{
        for rm := range r.Chan </span><span class="cov0" title="0">{
                rmd := rm.Data
                prefix := ""
                // Pull a single prefix from the announcement, which may have more than one.
                if len(rmd.Announcements) &gt; 0 </span><span class="cov0" title="0">{
                        if len(rmd.Announcements[0].Prefixes) &gt; 0 </span><span class="cov0" title="0">{
                                prefix = rmd.Announcements[0].Prefixes[0]
                                fmt.Printf("Prefix: %v\n", prefix)
                        }</span>
                }
                <span class="cov0" title="0">log.Infof("Got a prefix: %v / announcement\n", prefix)
                // TODO(morrowc): This doesn't appear to be working properly.
                if r.CheckASPath(rmd) &amp;&amp; r.CheckInvalidTransitAS(rmd) &amp;&amp;
                        r.CheckOrigins(rmd) &amp;&amp; r.CheckPrefix(rmd) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Message(%d): Peer/ASN -&gt; %v/%v Prefix1: %v\n", r.Records, rmd.Peer, rmd.PeerASN, prefix)
                }</span>
        }
        <span class="cov0" title="0">return "Done"</span>
}

// CheckASPath checks the filterable ASPath, if it's set.
// If not set, always return true.
func (r *RisLive) CheckASPath(rm *RisMessageData) bool <span class="cov8" title="1">{
        if len(r.Filter.ASPath) &gt; 0 </span><span class="cov8" title="1">{
                return rm.MatchASPath(r.Filter.ASPath)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// CheckInvalidTransitAS checks to see if there is a marked invalid ASN in the as-path.
// If there is no map, this check returns false: there is nothing to match, so no match.
func (r *RisLive) CheckInvalidTransitAS(rm *RisMessageData) bool <span class="cov8" title="1">{
        if len(r.Filter.InvalidTransitAS) &gt; 0 </span><span class="cov8" title="1">{
                return rm.InvalidTransitAS(r.Filter.InvalidTransitAS)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// CheckOrigins checks the inbound message origin against a list of possible origins.
// If there is no list of origins, return false, an origin must be specified in the filter.
func (r *RisLive) CheckOrigins(rm *RisMessageData) bool <span class="cov8" title="1">{
        if len(r.Filter.Origins) &gt; 0 </span><span class="cov8" title="1">{
                return rm.CheckOrigins(r.Filter.Origins)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// CheckPrefix will check each announcement in a message, and return true
// if there is a prefix in the message that matches the watched prefixes.
// These are exact matches of strings, there is no super/subnet/covering route
// check being performed, ie:
//   192.168.0.0/16 vs 192.168.0.0/16 - match
//   192.168.0.0/16 vs 192.168.0.0/24 - no match
// TODO(morrowc): Provide super/subnet verification of each announced prefix
// to the requestors list of supernets.
func (r *RisLive) CheckPrefix(rm *RisMessageData) bool <span class="cov8" title="1">{
        if len(r.Filter.Prefix) &gt; 0 </span><span class="cov8" title="1">{
                filterPrefixes := []*net.IPNet{}
                for _, prefix := range r.Filter.Prefix </span><span class="cov8" title="1">{
                        _, subnet, err := net.ParseCIDR(prefix)
                        if err != nil </span><span class="cov8" title="1">{
                                log.Infof("failed to convert filter prefix(%v) to IPNet: %v", prefix, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">filterPrefixes = append(filterPrefixes, subnet)</span>
                }
                <span class="cov8" title="1">for _, anns := range rm.Announcements </span><span class="cov8" title="1">{
                        for _, prefix := range anns.Prefixes </span><span class="cov8" title="1">{
                                for _, check := range filterPrefixes </span><span class="cov8" title="1">{
                                        announcementIP, _, err := net.ParseCIDR(prefix)
                                        if err != nil </span><span class="cov8" title="1">{
                                                log.Infof("announcement prefix(%v) not parsed as CIDR: %v", prefix, err)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if check.Contains(announcementIP) </span><span class="cov8" title="1">{
                                                return true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

func main() <span class="cov0" title="0">{
        flag.Parse()
        rf := &amp;RisFilter{
                Prefix:  []string{"130.137.85.0/24", "199.168.88.0/22", "8.8.8.0/24", "8.8.4.0/24", "216.239.32.0/19"},
                Origins: []string{"15169", "54054", "396982"},
        }
        r := NewRisLive(risLive, risFile, risClient, rf, buffer)

        go r.Listen()
        result := r.Get(r.Filter)
        fmt.Printf("Result: %v\n", result)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
